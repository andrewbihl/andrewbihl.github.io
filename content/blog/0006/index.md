---
title: TBD
description: TBD
date: 2020-06-21T13:00:00Z
location: Waynesboro, VA
showLocation: false
tags: [software engineering, learning, students, university]
article: true
---


> As we know, there are known knowns; there are things we know we know. We also know there are known unknowns; that is to say we know there are some things we do not know. But there are also unknown unknowns—the ones we don’t know we don’t know. 
> 
> – Donald Rumsfeld

It's easy to forget how challenging it is to learn to write software. I am referring specifically to the *first* time you learn to write software, as opposed to just programming. 

For me, there was a brutal gap between learning to program and learning to make software. My technical education started with a class in high school which qualified me to take the 2nd-level Computer Science when I arrived at university. From that point on, it took until the summer after sophomore year until I could turn my "programming" into a functional product which could be updated, deployed, and used.

The more than two years before then were frustrating and confusing. In *Data Structures and Algorithms* I learned to think about time and space complexity, and to consider the relation between the representation of data and its use. *Computer Architecture* was a revelation–I've never had a more satisfying learning experience than when I built a simulated CPU in Logisim. I began the course having only ever interacted with Java inside of an IDE, and I left feeling like I could explain how a computer could work in principle. 

Still, though, I could not connect the dots to making software. Worse yet, I didn't even have the vocabulary to ask the questions necessary to inquire about it. All I had seen was single files of code written inside of *Eclipse*; fundamentally, I was just plugging inputs to the software which was the IDE. 

If I'd had the vocabulary and clarity to do so, I might have asked:
- How does my code actually get run? All I've ever done is hit the green play arrow in an IDE.
- What needs to happen to bundle my code up and deliver it to someone?
- How does code interact with code written in a different language?
- How can I code something which produces something useful like a graphical interface? 
- How can my code interact with audio or video? Do those things include code inside them?
- How does code interact with the file system?
- How the hell is all this code being run on the internet? What happens when I go to a website?
- How do computers communicate with each other? 


## Professors did not teach software skills

With a few exceptions, professors in the introductory courses of university had no interest in teaching the practical details associated with making software. They were, it seemed, of the opinion that it wasn't worth their time to teach these things. Perhaps that was fair. You don't need a PhD in algorithms to walk someone through the command line, and you don't get one in order to do so.

Still, understanding the command line might have helped when learning assembly code.

Nonetheless, I was swamped in classes and devoting enough of my time between studying, class time, activities and socializing that I figuring out these things on my own felt like a remote possibility. It's one thing to try to carve time out to do something. But I felt like I had no breathing room in general, and I didn't even know what I needed to know or how to go about learning it. I just knew I was missing a lot of information.


## Ego

My pride was affected by all this as well. I knew some students who had internships during the summer after our first year; by that point I had only taken a single CS class at college. I had no idea where or how they were getting these positions (I later realized almost all of them had some family connection). Some were genuinely capable developers, as they had had years of programming experience from private secondary schools or parents who could teach them about the craft and the industry. At the time I had no idea where they were getting these abilities, I only knew that I was behind. 

On the occassions that I did sit down and attempt to learn something, I felt stupid in the face of issues. Even seemingly simple tutorials would inevitably come with perplexing environment setups, installation issues, unexpected and unexplained errors. And they would almost always refer to other technologies and information that I did not have, creating an endless looping network of rabbit holes where nothing felt like the proper starting point.


## Eventually I did learn

The challenge was, fundamentally, that I had to learn something which was ill-defined and which I did not know how to start. Eventually though, I did get over that hump.

What actually occurred was that I participated in a coding bootcamp in the summer after my sophomore year. And, like my classmates with early experience and internships, it was made possible by a family relationship. I had a relative wanting to start a business around an iOS app and wanted me to help. So that summer I took the bootcamp and then worked on the app. 

I go back and forth about whether it was worth it. Bootcamps are expensive, especially when you are not immediately going to a full-time job afterward.

When I look back at what the bootcamp consisted of, it seems clear that it was not worth the money. All of the information could be found online for free, and none of it was so hard that I could not figure it out in a reasonable time. But this is how it appears *in retrospect*–now that I know how to build iOS app (and plenty of other things) I feel this way.

But when I reflect on where I was at the time, I see a different picture: I started off feeling completely incapable and unable to learn, and 12 weeks later I felt empowered to figure out whatever I needed to get the job done. Furthermore, learning other areas (like web development for example) seemed less foreign now once I had something to compare to. **It provided an anchor to frame my learning going forward.**


## Lessons

Since then, I've considered this time period in different ways.  Sometimes I feel sure that I'd have been better off if I had gotten this learning earlier, if someone could have just sat me down and helped me see what the path forward looked like.

Should my degree program have included practical curriculum early on?

Was I even prepared to get this information if someone gave it to me? It's possible that the frustration I experienced was an inevitable process, and that one way or another I was only going to learn bits and pieces at a time without changing the time required to understand the whole picture.

Still, I feel that the curriculum of the bootcamp was such that I could have had a successful experience if I'd taken it before entering college (having taken the AP Computer Science class in high school). I wonder how the rest of my education may have proceeded if that had been the case.

Nonetheless, the experience taught me a great deal about learning. Before university I'd not developed the skillls and habits to learn difficult things; the pace and scope of my courses was unlike anything I'd had in my public schooling, and I'd never had to struggle with anything academic other than my own inattention.

I developed a mental framework of how to approach learning new territory, how to deal with uncertainty, and how to make consistent progress in difficult things. In the same way that learning iOS development provided a framework to learn other software skills, the process taught me about self-teaching and skill development.